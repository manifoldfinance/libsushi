import{createAction as d,createReducer as N}from"@reduxjs/toolkit";import{toUtf8String as f}from"@ethersproject/strings";var A=(r=>(r.MAINNET="1",r.GORELI="5",r))(A||{});let L=["1"];var C=(r=>(r.MAINNET="0x1",r))(C||{});const V=["0x1"],x=r=>"https://api.sushirelay.com/v1",H=x(),g=d("transactions/addTransaction"),v=d("transactions/clearAllTransactions"),I=d("transactions/finalizeTransaction"),S=d("transactions/checkedTransaction"),O=d("transactions/updatePrivateTxStatus");var n=(r=>(r.UNCHECKED="UNCHECKED",r.PROCESSING="PROCESSING",r.OK="OK",r.INDETERMINATE="INDETERMINATE",r.ERROR="ERROR",r))(n||{});function _(r){throw new Error("[#sushiguard]: Function Error.")}var J=Object.freeze({__proto__:null,PrivateTxState:n,privateTx:_});/**
 *
 * @class PrivateTransaction
 * @license GPL-3.0-Only
 * @see {@link https://docs.manifoldfinance.com}
 * @since 2022.03
 * @latest 2022.06
 * @version 0.2.0
 *
 */function G(r){return r?.privateTx?r?.privateTx?.state===n.UNCHECKED||r?.privateTx?.state===n.PROCESSING:!r?.receipt}function q(r){return r?.privateTx?r?.privateTx?.state===n.OK&&!!r&&(r.receipt?.status===1||typeof r.receipt?.status>"u"):!!r&&(r.receipt?.status===1||typeof r.receipt?.status>"u")}function B(r){return r?.privateTx?r?.privateTx?.state===n.INDETERMINATE:!1}function R(r){return r?(new Date().getTime()-r.addedTime)/1e3/60:0}function W(r){return r?R(r)>60:!1}const l=()=>new Date().getTime(),h={};var D=N(h,r=>r.addCase(g,(e,{payload:{chainId:a,from:o,hash:t,approval:s,summary:i,claim:u,privateTx:c=!1}})=>{if(e[a]?.[t])throw Error("Attempted to add existing transaction.");const E=e[a]??{};E[t]={hash:t,approval:s,summary:i,claim:u,from:o,addedTime:l(),...c?{privateTx:{state:n.UNCHECKED,status:void 0}}:{}},e[a]=E}).addCase(v,(e,{payload:{chainId:a}})=>{!e[a]||(e[a]={})}).addCase(S,(e,{payload:{chainId:a,hash:o,blockNumber:t}})=>{const s=e[a]?.[o];!s||(s.lastCheckedBlockNumber?s.lastCheckedBlockNumber=Math.max(t,s.lastCheckedBlockNumber):s.lastCheckedBlockNumber=t)}).addCase(I,(e,{payload:{hash:a,chainId:o,receipt:t}})=>{const s=e[o]?.[a];!s||(s.receipt=t,s.confirmedTime=l())}).addCase(O,(e,{payload:{chainId:a,hash:o,status:t}})=>{const s=e[a]?.[o];if(!s)return;if(!s.privateTx)throw new Error("Invalid update private tx call to a non private tx");const i=s.privateTx?.state;s.privateTx?.status;const u=R(s);if(i&&(i===n.ERROR||i===n.INDETERMINATE||i===n.OK))return;let c=n.PROCESSING;t.receivedAt&&t.relayedAt&&!t.relayFailure&&t.minedAt&&(c=n.OK),t.receivedAt&&t.relayFailure&&t.relayResponses&&Object.values(t.relayResponses).reduceRight((E,p)=>E||!!(p.error||p.response.error),!1)&&(c=n.ERROR),t.receivedAt&&t.relayedAt&&t.relayFailure&&t.minedAt&&(c=n.INDETERMINATE),u>3&&(c=n.INDETERMINATE),s.privateTx.state=c??n.UNCHECKED,s.privateTx.status=t})),z=Object.freeze({__proto__:null,default:D,initialState:h});class y extends Error{constructor(e,a,o){super(e),this.req=a,this.res=o}}function Q(r,{jsonrpc:e="2.0",id:a=new Date().getTime(),method:o="",params:t=[]}){return fetch(r,{headers:{"Content-Type":"application/json"},method:"POST",body:JSON.stringify({jsonrpc:e,id:a,method:o,params:t})}).then(s=>{if(s.status!==200)throw new y(s.statusText,{jsonrpc:e,id:a,method:o,params:t},s);return s.json()})}function X(r){if(r.jsonrpc!=="2.0"||typeof r.id!="string"&&typeof r.id!="number"&&r.id!==null||"result"in r&&"error"in r||!("result"in r)&&!("error"in r)||r.error&&typeof r.error.code!="number"||r.error&&typeof r.error.message!="string")throw new Error(`Expected JSON-RPC response, received something else.
${JSON.stringify(r)}`);return!0}function Z(r){return!!r.result&&!r.error}function Y(r){return!!r.error&&!r.result}const rr="0x000000000000000000000000000000000000dead",er="0x0000000000000000000000000000000000000000",tr="",sr="0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000";class m extends Error{constructor(e,a,o,t){if(!Number.isInteger(e))throw new Error('"code" must be an integer.');if(!a||typeof a!="string")throw new Error('"message" must be a nonempty string.');super(a),this.code=e,this.data=t,this.internal=o}}class T extends m{constructor(e,a,o,t){if(!(Number.isInteger(e)&&e>=1e3&&e<=4999))throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');super(e,a,o,t)}}class ar extends Error{constructor(){super(...arguments),this.name="AddChainError",this.message="Error adding chain"}}class or extends Error{constructor(){super(...arguments),this.name="ChainNotConfigured",this.message="Chain not configured"}}class nr extends Error{constructor(){super(...arguments),this.name="ConnectorAlreadyConnectedError",this.message="Connector already connected"}}class ir extends Error{constructor(){super(...arguments),this.name="ConnectorNotFoundError",this.message="Connector not found"}}class cr extends T{constructor(e){super(4902,"Error switching chain",e),this.name="SwitchChainError"}}class dr extends Error{constructor(){super(...arguments),this.name="SwitchChainNotSupportedError",this.message="Switch chain not supported by connector"}}class Er extends T{constructor(e){super(4001,"User rejected request",e),this.name="UserRejectedRequestError"}}class ur extends m{constructor(e){super(-32002,"Resource unavailable",e),this.name="ResourceUnavailable"}}function w(r,e){return r&&r.code===e}function pr(r){return w(r,"CALL_EXCEPTION")}const lr=async(r,e,a)=>{if(typeof r!="object")throw TypeError(`tx argument ${r} must be a transaction object`);if(typeof e!="object")throw TypeError(`receipt argument ${e} must be a transaction receipt object`);if(e.status)throw TypeError("Transaction did not fail. Can only read the revert reason from failed transactions");if(!e.transactionHash)throw TypeError("There is no transaction hash on the receipt object");if(e.gasUsed===r.gasLimit)throw Error("Transaction failed as it ran out of gas.");let o;try{o=(await a.call({...r},e.blockNumber)).slice(2)}catch(t){if(t.message.startsWith("Node error: ")){const s=t.message.slice(12),i=JSON.parse(s);if(!i.data)throw Error("Failed to parse data field error object:"+s);if(i.data.startsWith("Reverted 0x"))o=i.data.slice(11);else if(i.data.startsWith("0x"))o=i.data.slice(2);else throw Error("Failed to parse data field of error object:"+s)}else throw Error("Failed to parse error message from Ethereum call: "+t.message)}return $(o)},$=r=>{const e=parseInt(r.slice(72,136),16),a=r.slice(8+128,8+128+e*2);return f("0x"+a)},b="PARSE_ERROR",P="INVALID_REQUEST",M="METHOD_NOT_FOUND",U="INVALID_PARAMS",j="INTERNAL_ERROR",K="SERVER_ERROR",Rr=[-32700,-32600,-32601,-32602,-32603],hr=[-32e3,-32099],mr={[b]:{code:-32700,message:"Parse error"},[P]:{code:-32600,message:"Invalid Request"},[M]:{code:-32601,message:"Method not found"},[U]:{code:-32602,message:"Invalid params"},[j]:{code:-32603,message:"Internal error"},[K]:{code:-32e3,message:"Server error"}};export{ar as AddChainError,er as AddressZero,rr as BURN_ADDRESS,A as ChainId,or as ChainNotConfiguredError,nr as ConnectorAlreadyConnectedError,ir as ConnectorNotFoundError,sr as DeadAddress,tr as EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,y as HttpJsonRpcError,j as INTERNAL_ERROR,U as INVALID_PARAMS,P as INVALID_REQUEST,H as MAINNET_RPC_URL,M as METHOD_NOT_FOUND,C as OPENMEV_METAMASK_CHAIN_ID,V as OPENMEV_METAMASK_SUPPORTED_NETWORKS,L as OPENMEV_SUPPORTED_NETWORKS,b as PARSE_ERROR,J as PrivateTransaction,n as PrivateTxState,T as ProviderRpcError,Rr as RESERVED_ERROR_CODES,z as Reducer,ur as ResourceUnavailableError,m as RpcError,K as SERVER_ERROR,hr as SERVER_ERROR_CODE_RANGE,mr as STANDARD_ERROR_MAP,cr as SwitchChainError,dr as SwitchChainNotSupportedError,Er as UserRejectedRequestError,g as addTransaction,S as checkedTransaction,v as clearAllTransactions,Q as fetchJsonRpc,I as finalizeTransaction,lr as getTransactionError,pr as isCallException,w as isError,Y as isJsonRpcError,Z as isJsonRpcSuccess,W as isTxExpired,B as isTxIndeterminate,G as isTxPending,q as isTxSuccessful,$ as parseReasonCode,_ as privateTx,R as txMinutesPending,O as updatePrivateTxStatus,X as validateJsonRpcResponse};
//# sourceMappingURL=index.mjs.map
