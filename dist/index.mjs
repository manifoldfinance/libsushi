import{createAction as d,createReducer as f}from"@reduxjs/toolkit";import{toUtf8String as N}from"@ethersproject/strings";var C=(r=>(r.MAINNET="1",r.GORELI="5",r))(C||{});let V=["1"];var A=(r=>(r.MAINNET="0x1",r))(A||{});const H=["0x1"],g=r=>"https://api.sushirelay.com/v1",J=g(),x=d("transactions/addTransaction"),O=d("transactions/clearAllTransactions"),S=d("transactions/finalizeTransaction"),v=d("transactions/checkedTransaction"),I=d("transactions/updatePrivateTxStatus");var n=(r=>(r.UNCHECKED="UNCHECKED",r.PROCESSING="PROCESSING",r.OK="OK",r.INDETERMINATE="INDETERMINATE",r.ERROR="ERROR",r))(n||{});function _(r){throw new Error("[#sushiguard]: Function Error.")}var G=Object.freeze({__proto__:null,PrivateTxState:n,privateTx:_});/**
 *
 * @class PrivateTransaction
 * @license GPL-3.0-Only
 * @see {@link https://docs.manifoldfinance.com}
 * @since 2022.03
 * @latest 2022.06
 * @version 0.2.0
 *
 */function q(r){return r?.privateTx?r?.privateTx?.state===n.UNCHECKED||r?.privateTx?.state===n.PROCESSING:!r?.receipt}function B(r){return r?.privateTx?r?.privateTx?.state===n.OK&&!!r&&(r.receipt?.status===1||typeof r.receipt?.status>"u"):!!r&&(r.receipt?.status===1||typeof r.receipt?.status>"u")}function W(r){return r?.privateTx?r?.privateTx?.state===n.INDETERMINATE:!1}function l(r){return r?(new Date().getTime()-r.addedTime)/1e3/60:0}function z(r){return r?l(r)>60:!1}const p=()=>new Date().getTime(),h={};var D=f(h,r=>r.addCase(x,(e,{payload:{chainId:s,from:o,hash:t,approval:a,summary:i,claim:u,privateTx:c=!1}})=>{if(e[s]?.[t])throw Error("Attempted to add existing transaction.");const E=e[s]??{};E[t]={hash:t,approval:a,summary:i,claim:u,from:o,addedTime:p(),...c?{privateTx:{state:n.UNCHECKED,status:void 0}}:{}},e[s]=E}).addCase(O,(e,{payload:{chainId:s}})=>{!e[s]||(e[s]={})}).addCase(v,(e,{payload:{chainId:s,hash:o,blockNumber:t}})=>{const a=e[s]?.[o];!a||(a.lastCheckedBlockNumber?a.lastCheckedBlockNumber=Math.max(t,a.lastCheckedBlockNumber):a.lastCheckedBlockNumber=t)}).addCase(S,(e,{payload:{hash:s,chainId:o,receipt:t}})=>{const a=e[o]?.[s];!a||(a.receipt=t,a.confirmedTime=p())}).addCase(I,(e,{payload:{chainId:s,hash:o,status:t}})=>{const a=e[s]?.[o];if(!a)return;if(!a.privateTx)throw new Error("Invalid update private tx call to a non private tx");const i=a.privateTx?.state;a.privateTx?.status;const u=l(a);if(i&&(i===n.ERROR||i===n.INDETERMINATE||i===n.OK))return;let c=n.PROCESSING;t.receivedAt&&t.relayedAt&&!t.relayFailure&&t.minedAt&&(c=n.OK),t.receivedAt&&t.relayFailure&&t.relayResponses&&Object.values(t.relayResponses).reduceRight((E,R)=>E||!!(R.error||R.response.error),!1)&&(c=n.ERROR),t.receivedAt&&t.relayedAt&&t.relayFailure&&t.minedAt&&(c=n.INDETERMINATE),u>3&&(c=n.INDETERMINATE),a.privateTx.state=c??n.UNCHECKED,a.privateTx.status=t})),Q=Object.freeze({__proto__:null,default:D,initialState:h});class y extends Error{constructor(e,s,o){super(e),this.req=s,this.res=o}}function X(r,{jsonrpc:e="2.0",id:s=new Date().getTime(),method:o="",params:t=[]}){return fetch(r,{headers:{"Content-Type":"application/json"},method:"POST",body:JSON.stringify({jsonrpc:e,id:s,method:o,params:t})}).then(a=>{if(a.status!==200)throw new y(a.statusText,{jsonrpc:e,id:s,method:o,params:t},a);return a.json()})}function Z(r){if(r.jsonrpc!=="2.0"||typeof r.id!="string"&&typeof r.id!="number"&&r.id!==null||"result"in r&&"error"in r||!("result"in r)&&!("error"in r)||r.error&&typeof r.error.code!="number"||r.error&&typeof r.error.message!="string")throw new Error(`Expected JSON-RPC response, received something else.
${JSON.stringify(r)}`);return!0}function Y(r){return!!r.result&&!r.error}function rr(r){return!!r.error&&!r.result}const er="0x000000000000000000000000000000000000dead",tr="0x0000000000000000000000000000000000000000",ar="",sr="0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000";class m extends Error{constructor(e,s,o,t){if(!Number.isInteger(e))throw new Error('"code" must be an integer.');if(!s||typeof s!="string")throw new Error('"message" must be a nonempty string.');super(s),this.code=e,this.data=t,this.internal=o}}class T extends m{constructor(e,s,o,t){if(!(Number.isInteger(e)&&e>=1e3&&e<=4999))throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');super(e,s,o,t)}}class or extends Error{constructor(){super(...arguments),this.name="AddChainError",this.message="Error adding chain"}}class nr extends Error{constructor(){super(...arguments),this.name="ChainNotConfigured",this.message="Chain not configured"}}class ir extends Error{constructor(){super(...arguments),this.name="ConnectorAlreadyConnectedError",this.message="Connector already connected"}}class cr extends Error{constructor(){super(...arguments),this.name="ConnectorNotFoundError",this.message="Connector not found"}}class dr extends T{constructor(e){super(4902,"Error switching chain",e),this.name="SwitchChainError"}}class Er extends Error{constructor(){super(...arguments),this.name="SwitchChainNotSupportedError",this.message="Switch chain not supported by connector"}}class ur extends T{constructor(e){super(4001,"User rejected request",e),this.name="UserRejectedRequestError"}}class Rr extends m{constructor(e){super(-32002,"Resource unavailable",e),this.name="ResourceUnavailable"}}function $(r,e){return r&&r.code===e}function pr(r){return $(r,"CALL_EXCEPTION")}const lr=async(r,e,s)=>{if(typeof r!="object")throw TypeError(`tx argument ${r} must be a transaction object`);if(typeof e!="object")throw TypeError(`receipt argument ${e} must be a transaction receipt object`);if(e.status)throw TypeError("Transaction did not fail. Can only read the revert reason from failed transactions");if(!e.transactionHash)throw TypeError("There is no transaction hash on the receipt object");if(e.gasUsed===r.gasLimit)throw Error("Transaction failed as it ran out of gas.");let o;try{o=(await s.call({...r},e.blockNumber)).slice(2)}catch(t){if(t.message.startsWith("Node error: ")){const a=t.message.slice(12),i=JSON.parse(a);if(!i.data)throw Error("Failed to parse data field error object:"+a);if(i.data.startsWith("Reverted 0x"))o=i.data.slice(11);else if(i.data.startsWith("0x"))o=i.data.slice(2);else throw Error("Failed to parse data field of error object:"+a)}else throw Error("Failed to parse error message from Ethereum call: "+t.message)}return b(o)},b=r=>{const e=parseInt(r.slice(72,136),16),s=r.slice(8+128,8+128+e*2);return N("0x"+s)},w="RESOURCE_ERROR",P="PARSE_ERROR",M="INVALID_REQUEST",U="METHOD_NOT_FOUND",j="INVALID_PARAMS",K="INTERNAL_ERROR",k="SERVER_ERROR",hr=[-32001,-32700,-32600,-32601,-32602,-32603],mr=[-32e3,-32099],Tr={[w]:{code:-32001,message:"Err.32001# Resource not found"},[P]:{code:-32700,message:"Err.32700# Parse error"},[M]:{code:-32600,message:"Err.32601# Invalid Request"},[U]:{code:-32601,message:"Err.32601# Method not found"},[j]:{code:-32602,message:"Err.32602# Invalid params"},[K]:{code:-32603,message:"Err.32603# Internal error"},[k]:{code:-32e3,message:"Err.32000# Server unable to locate canonical block"}};export{or as AddChainError,tr as AddressZero,er as BURN_ADDRESS,C as ChainId,nr as ChainNotConfiguredError,ir as ConnectorAlreadyConnectedError,cr as ConnectorNotFoundError,sr as DeadAddress,ar as EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,y as HttpJsonRpcError,K as INTERNAL_ERROR,j as INVALID_PARAMS,M as INVALID_REQUEST,J as MAINNET_RPC_URL,U as METHOD_NOT_FOUND,A as OPENMEV_METAMASK_CHAIN_ID,H as OPENMEV_METAMASK_SUPPORTED_NETWORKS,V as OPENMEV_SUPPORTED_NETWORKS,P as PARSE_ERROR,G as PrivateTransaction,n as PrivateTxState,T as ProviderRpcError,hr as RESERVED_ERROR_CODES,w as RESOURCE_ERROR,Q as Reducer,Rr as ResourceUnavailableError,m as RpcError,k as SERVER_ERROR,mr as SERVER_ERROR_CODE_RANGE,Tr as STANDARD_ERROR_MAP,dr as SwitchChainError,Er as SwitchChainNotSupportedError,ur as UserRejectedRequestError,x as addTransaction,v as checkedTransaction,O as clearAllTransactions,X as fetchJsonRpc,S as finalizeTransaction,lr as getTransactionError,pr as isCallException,$ as isError,rr as isJsonRpcError,Y as isJsonRpcSuccess,z as isTxExpired,W as isTxIndeterminate,q as isTxPending,B as isTxSuccessful,b as parseReasonCode,_ as privateTx,l as txMinutesPending,I as updatePrivateTxStatus,Z as validateJsonRpcResponse};
//# sourceMappingURL=index.mjs.map
